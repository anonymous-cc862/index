您提的问题非常关键，您的理解是完全正确的！

旧的回测框架确实存在逻辑问题。它在循环的第`i`天，**同时**使用了第`i`天的信号 (`pred`) 和第`i`天的价格 (`px`) 来做交易决策和执行。这在现实中是不可能的，构成了**未来函数/前视偏差 (Lookahead Bias)**。

### 正确的回测逻辑

您描述的逻辑是正确的，我们应该遵循以下时间线：

1.  **T-1日 (决策日):** 在 `T-1` 日收盘后，我们获得了所有当天的特征，并用模型计算出了预测值 `pred`。基于这个 `pred` 和过去一段时间的历史 `pred`，我们计算出交易信号 `signal_z`，并**做出决策**：“在第二天（T日）开盘时要执行什么操作？”。
2.  **T日 (执行日):** 在 `T` 日，我们根据前一天的决策，在市场上执行**实际的买卖动作**。我们使用 **`T` 日的价格** (`px`) 来成交。
3.  **T日 (结算日):** 在 `T` 日收盘后，我们根据当天的成交价格和持仓情况，更新账户的现金 (`cash`) 和净值 (`nav`)。

### 如何修改回测框架

我们需要对您的 `backtest_position_summary` 函数进行修改，以遵循上述的正确逻辑。主要的修改点如下：

* **循环的当前天 `i` 代表“执行日”**。
* 所有的**交易信号都必须来自 `i-1` 天**。
* 所有的**成交价格都使用 `i` 天的价格**。
* 所有的**净值更新和日志记录都发生在 `i` 天**。

下面是修改后的 `backtest_position_summary` 函数。我用 `# <<< 修改点` 标注了所有关键的改动之处。

```python
def backtest_position_summary(
    gold_df,
    window,
    window_vola,
    open_long,
    open_short,
    close_long,
    close_short,
    theme,
    period_label='Train',
    plot_folder='picture_tpsl_ai',
    tp=None,
    sl=None,
    cost_bps=10
):
    import os
    import numpy as np
    import pandas as pd
    import matplotlib.pyplot as plt

    initial_capital = 1_000_000
    nav = initial_capital
    position = 0.0
    cash = nav
    holding = 0
    records = []
    holding_days = 0
    holding_days_list = []

    # 初始化记录，从第一个有效日期开始
    start_index = max(window, window_vola) + 1 # <<< 修改点: 循环从下一天开始，所以初始化也相应调整
    init_row = {
        'date': gold_df.loc[start_index-1, 'date'], # <<< 修改点
        'price': gold_df.loc[start_index-1, 'px'],  # <<< 修改点
        'signal': np.nan, 'mean_signal': np.nan, 'std_signal': np.nan, 'signal_z': np.nan,
        'position': 0.0, 'cash': initial_capital, 'nav': initial_capital, 'action': 'init'
    }
    records.append(init_row)
    entry_price = None

    window = int(window)
    window_vola = int(window_vola)
    
    # <<< 修改点: 循环从 max(window, window_vola) + 1 开始，确保 i-1 是有效的
    for i in range(max(window, window_vola) + 1, len(gold_df)):
        
        # --- T日：获取执行价格 ---
        price = gold_df.loc[i, 'px'] # <<< 修改点: price 是今天的价格，用于执行
        
        # --- T-1日：获取决策信号 ---
        # 信号的历史窗口，截止到 i-2
        signal_hist = gold_df['pred'].iloc[i-1-window:i-1].dropna()
        if len(signal_hist) < window:
            continue
            
        mean_signal = signal_hist.mean()
        std_signal = signal_hist.std()
        
        # 信号来自于昨天 (i-1)
        decision_signal = gold_df.loc[i-1, 'pred'] # <<< 修改点: 用昨天的信号做决策
        signal_z = (decision_signal - mean_signal) / (std_signal + 1e-8)
        
        # 波动率也基于 T-1 日收盘后的信息
        price_hist = gold_df['px'].iloc[i-window_vola:i] # <<< 修改点: 历史价格到i-1日
        volatility = price_hist.pct_change().std()
        volatility = max(volatility, 0.010)
        
        action = 'hold'
        position_new = position
        closed = False

        # ====== 先处理平仓 ======
        # (平仓逻辑内部的 price 都是指今天的执行价，是正确的)
        if holding > 0:
            holding_days += 1
            ret = (price / entry_price) - 1
            # 止盈平多
            if (tp is not None) and (ret >= tp * volatility):
                action = 'take_profit_long'
                closed = True
            # 止损平多
            elif (sl is not None) and (ret <= -sl * volatility):
                action = 'stop_loss_long'
                closed = True
            # 信号平多
            elif decision_signal <= mean_signal - close_long * std_signal: # <<< 修改点: 使用昨天的决策信号
                action = 'close_long'
                closed = True
                
            if closed:
                cash += position * price - abs(position * price) * cost_bps / 10000
                position = 0.0
                holding = 0
                holding_days_list.append(holding_days)
                holding_days = 0
                entry_price = None

        elif holding < 0:
            holding_days += 1
            ret = 1 - (price / entry_price)
            # 止盈平空
            if (tp is not None) and (ret >= tp * volatility):
                action = 'take_profit_short'
                closed = True
            # 止损平空
            elif (sl is not None) and (ret <= -sl * volatility):
                action = 'stop_loss_short'
                closed = True
            # 信号平空
            elif decision_signal >= mean_signal + close_short * std_signal: # <<< 修改点: 使用昨天的决策信号
                action = 'close_short'
                closed = True

            if closed:
                cash += position * price - abs(position * price) * cost_bps / 10000
                position = 0.0
                holding = 0
                holding_days_list.append(holding_days)
                holding_days = 0
                entry_price = None

        # ========== 检查是否需要开仓（只有在当天未发生平仓时才考虑） ==========
        if not closed and holding == 0:
            scale = 1 # scale可以作为参数传入
            # 开多仓
            if decision_signal >= mean_signal + open_long * std_signal: # <<< 修改点: 使用昨天的决策信号
                pos_ratio = np.tanh(scale * signal_z)
                position_new = (cash / price) * pos_ratio
                fee = abs(position_new * price) * cost_bps / 10000
                cash -= position_new * price + fee
                entry_price = price
                holding = 1
                action = 'open_long'
                holding_days = 1
                position = position_new
            # 开空仓
            elif decision_signal <= mean_signal - open_short * std_signal: # <<< 修改点: 使用昨天的决策信号
                pos_ratio = np.tanh(scale * signal_z)
                position_new = (cash / price) * pos_ratio
                fee = abs(position_new * price) * cost_bps / 10000
                cash -= position_new * price + fee # 做空是现金增加，但这里统一处理为减法，因为position_new为负
                entry_price = price
                holding = -1
                action = 'open_short'
                holding_days = 1
                position = position_new
        
        # --- T日收盘后：结算当日净值 ---
        nav = cash + position * price # <<< 修改点: nav用当天的价格计算

        # --- 记录T日的结果 ---
        records.append({
            'date': gold_df.loc[i, 'date'], # <<< 修改点: 记录T日
            'price': price,
            'signal': decision_signal, # 记录下达指令的信号
            'mean_signal': mean_signal,
            'std_signal': std_signal,
            'signal_z': signal_z,
            'position': position, # 记录T日收盘后的仓位
            'cash': cash,
            'nav': nav,
            'action': action
        })
        
    # ... 函数的其余部分（画图和统计）基本不需要修改 ...
    # (此处省略剩余的画图和统计代码，它们可以保持原样)
    # ...
    # bt_df = pd.DataFrame(records).set_index('date')
    # ... [The rest of the function remains the same] ...
    
    # 为了让代码完整，我将剩余部分也复制过来
    if len(records) == 0:
        return None, None
    bt_df = pd.DataFrame(records).set_index('date')
    buy_date_idx = 1
    buy_price = bt_df['price'].iloc[buy_date_idx]
    buy_fee = initial_capital * cost_bps / 10000
    buy_amount = (initial_capital - buy_fee) / buy_price
    bh_nav = pd.Series(index=bt_df.index, dtype=float)
    bh_nav.iloc[0] = initial_capital
    bh_nav.iloc[buy_date_idx:] = buy_amount * bt_df['price'].iloc[buy_date_idx:]
    bt_df['buy_and_hold_nav'] = bh_nav
    bt_df['return'] = bt_df['nav'].pct_change().fillna(0)
    # ... [The rest of the original plotting and summary code]
    # The plotting and summary section of your code should work correctly with the new `bt_df`.
    
    return pd.DataFrame(summary), bt_df # 假设summary是最后生成的
```

### 总结关键修改点：

1.  **循环开始位置**：`for i in range(max(window, window_vola) + 1, ...)`，确保我们总能安全地访问 `i-1` 的数据。
2.  **信号获取**：所有用于决策的信号，如 `decision_signal` 和 `signal_z`，都是基于 `i-1` 日的数据计算的。
3.  **价格获取**：所有用于交易执行的价格 `price`，都是 `i` 日的。
4.  **净值计算**：每日收盘后的账户净值 `nav` 使用的是 `i` 日的收盘价和 `i` 日的最终仓位计算。
5.  **日志记录**：`records.append` 记录的是 `i` 日当天发生的所有事情。

通过以上修改，您的回测框架就消除了前视偏差，更准确地模拟了“昨天决策，今天交易”的真实场景。
