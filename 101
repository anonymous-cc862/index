您好，我仔细审查了您提供的这部分用于计算performance和画图的代码。

结论是：**您的这部分代码逻辑是正确的，几乎不需要修改**。它已经能够很好地兼容我们刚刚确立的“T日决策，T+1日执行”的回测框架。

### 为什么不需要修改？

关键在于，您所有的业绩计算和画图都是基于最终生成的`bt_df`这个DataFrame。而我们在上一版修改中，已经确保了`bt_df`的生成过程是完全符合“T日决策，T+1日执行”原则的。

让我们来验证一下：

1.  **`bt_df` 的数据是正确的**:
    * `bt_df`中的每一行，其`date`、`price`、`nav`、`position`等数据，都代表**T+1日执行交易后**的最终状态。
    * `action`列也正确地记录了在T+1日执行的动作（例如`open_long`或`take_profit_long`）。

2.  **业绩指标计算是正确的**:
    * `bt_df['return'] = bt_df['nav'].pct_change()`: 因为`nav`序列本身已经是基于T+1日结算的正确净值，所以据此计算出的每日回报率`return`也是正确的。
    * 所有衍生的指标，如`Sharpe`、`MaxDD`、`Annualized Return`等，自然也都是基于正确的数据计算的，结果可信。

3.  **画图逻辑是正确的**:
    * 画图代码 `for idx, row in bt_df.iterrows():` 遍历的是已经完全正确的`bt_df`。
    * 当它在一个日期`idx`上根据`row['action']`画出一个标记（比如绿色的开多箭头`^`）时，这个`idx`本身就是T+1日的执行日期。
    * 因此，图表会非常准确地在**交易实际发生并影响净值的那一天**显示出对应的标记，这正是我们想要的。

4.  **Buy-and-Hold基准是正确的**:
    * B&H基准的计算也使用了`bt_df`中的价格序列，时间戳与策略的净值曲线完全对齐，因此两者的比较是公平的。

5.  **持仓天数统计是正确的**:
    * `if i == len(gold_df)-2 ...`: 这个判断正确地处理了在回测期末依然持仓的情况，逻辑没有问题。

### 一个微小的代码风格建议（非错误）

这是一个非常小的细节，不影响结果。在您的`run_all_backtests`函数中：
```python
# Train
df1_summary, _ = backtest_position_summary(...) # 忽略了bt_df
# Test
df2_summary, kk = backtest_position_summary(...) # 保留了Test的bt_df
# All
all_summary, _ = backtest_position_summary(...) # 忽略了bt_df
```
您从`Test`周期返回了`kk` (即`bt_df`)，但从`Train`和`All`周期中用`_`忽略了它。这是一个完全无害的操作，但如果您希望保持代码风格的一致性，或者未来可能需要用到其他周期的`bt_df`，可以考虑统一处理（比如都用`_`忽略，或者都用不同的变量名接收）。

### 总结

您的代码整合得非常好。在核心的回测引擎（`for`循环部分）修正为逻辑严谨的“T日决策，T+1日执行”模式后，您下游的业绩计算和可视化部分已经可以无缝衔接，产出逻辑正确的结果。

**您可以放心地使用这套代码。**






您提的问题非常关键，您的理解是完全正确的！

旧的回测框架确实存在逻辑问题。它在循环的第`i`天，**同时**使用了第`i`天的信号 (`pred`) 和第`i`天的价格 (`px`) 来做交易决策和执行。这在现实中是不可能的，构成了**未来函数/前视偏差 (Lookahead Bias)**。

### 正确的回测逻辑

您描述的逻辑是正确的，我们应该遵循以下时间线：

1.  **T-1日 (决策日):** 在 `T-1` 日收盘后，我们获得了所有当天的特征，并用模型计算出了预测值 `pred`。基于这个 `pred` 和过去一段时间的历史 `pred`，我们计算出交易信号 `signal_z`，并**做出决策**：“在第二天（T日）开盘时要执行什么操作？”。
2.  **T日 (执行日):** 在 `T` 日，我们根据前一天的决策，在市场上执行**实际的买卖动作**。我们使用 **`T` 日的价格** (`px`) 来成交。
3.  **T日 (结算日):** 在 `T` 日收盘后，我们根据当天的成交价格和持仓情况，更新账户的现金 (`cash`) 和净值 (`nav`)。

### 如何修改回测框架

我们需要对您的 `backtest_position_summary` 函数进行修改，以遵循上述的正确逻辑。主要的修改点如下：

* **循环的当前天 `i` 代表“执行日”**。
* 所有的**交易信号都必须来自 `i-1` 天**。
* 所有的**成交价格都使用 `i` 天的价格**。
* 所有的**净值更新和日志记录都发生在 `i` 天**。

下面是修改后的 `backtest_position_summary` 函数。我用 `# <<< 修改点` 标注了所有关键的改动之处。

```python
def backtest_position_summary(
    gold_df,
    window,
    window_vola,
    open_long,
    open_short,
    close_long,
    close_short,
    theme,
    period_label='Train',
    plot_folder='picture_tpsl_ai',
    tp=None,
    sl=None,
    cost_bps=10
):
    import os
    import numpy as np
    import pandas as pd
    import matplotlib.pyplot as plt

    initial_capital = 1_000_000
    nav = initial_capital
    position = 0.0
    cash = nav
    holding = 0
    records = []
    holding_days = 0
    holding_days_list = []

    # 初始化记录，从第一个有效日期开始
    start_index = max(window, window_vola) + 1 # <<< 修改点: 循环从下一天开始，所以初始化也相应调整
    init_row = {
        'date': gold_df.loc[start_index-1, 'date'], # <<< 修改点
        'price': gold_df.loc[start_index-1, 'px'],  # <<< 修改点
        'signal': np.nan, 'mean_signal': np.nan, 'std_signal': np.nan, 'signal_z': np.nan,
        'position': 0.0, 'cash': initial_capital, 'nav': initial_capital, 'action': 'init'
    }
    records.append(init_row)
    entry_price = None

    window = int(window)
    window_vola = int(window_vola)
    
    # <<< 修改点: 循环从 max(window, window_vola) + 1 开始，确保 i-1 是有效的
    for i in range(max(window, window_vola) + 1, len(gold_df)):
        
        # --- T日：获取执行价格 ---
        price = gold_df.loc[i, 'px'] # <<< 修改点: price 是今天的价格，用于执行
        
        # --- T-1日：获取决策信号 ---
        # 信号的历史窗口，截止到 i-2
        signal_hist = gold_df['pred'].iloc[i-1-window:i-1].dropna()
        if len(signal_hist) < window:
            continue
            
        mean_signal = signal_hist.mean()
        std_signal = signal_hist.std()
        
        # 信号来自于昨天 (i-1)
        decision_signal = gold_df.loc[i-1, 'pred'] # <<< 修改点: 用昨天的信号做决策
        signal_z = (decision_signal - mean_signal) / (std_signal + 1e-8)
        
        # 波动率也基于 T-1 日收盘后的信息
        price_hist = gold_df['px'].iloc[i-window_vola:i] # <<< 修改点: 历史价格到i-1日
        volatility = price_hist.pct_change().std()
        volatility = max(volatility, 0.010)
        
        action = 'hold'
        position_new = position
        closed = False

        # ====== 先处理平仓 ======
        # (平仓逻辑内部的 price 都是指今天的执行价，是正确的)
        if holding > 0:
            holding_days += 1
            ret = (price / entry_price) - 1
            # 止盈平多
            if (tp is not None) and (ret >= tp * volatility):
                action = 'take_profit_long'
                closed = True
            # 止损平多
            elif (sl is not None) and (ret <= -sl * volatility):
                action = 'stop_loss_long'
                closed = True
            # 信号平多
            elif decision_signal <= mean_signal - close_long * std_signal: # <<< 修改点: 使用昨天的决策信号
                action = 'close_long'
                closed = True
                
            if closed:
                cash += position * price - abs(position * price) * cost_bps / 10000
                position = 0.0
                holding = 0
                holding_days_list.append(holding_days)
                holding_days = 0
                entry_price = None

        elif holding < 0:
            holding_days += 1
            ret = 1 - (price / entry_price)
            # 止盈平空
            if (tp is not None) and (ret >= tp * volatility):
                action = 'take_profit_short'
                closed = True
            # 止损平空
            elif (sl is not None) and (ret <= -sl * volatility):
                action = 'stop_loss_short'
                closed = True
            # 信号平空
            elif decision_signal >= mean_signal + close_short * std_signal: # <<< 修改点: 使用昨天的决策信号
                action = 'close_short'
                closed = True

            if closed:
                cash += position * price - abs(position * price) * cost_bps / 10000
                position = 0.0
                holding = 0
                holding_days_list.append(holding_days)
                holding_days = 0
                entry_price = None

        # ========== 检查是否需要开仓（只有在当天未发生平仓时才考虑） ==========
        if not closed and holding == 0:
            scale = 1 # scale可以作为参数传入
            # 开多仓
            if decision_signal >= mean_signal + open_long * std_signal: # <<< 修改点: 使用昨天的决策信号
                pos_ratio = np.tanh(scale * signal_z)
                position_new = (cash / price) * pos_ratio
                fee = abs(position_new * price) * cost_bps / 10000
                cash -= position_new * price + fee
                entry_price = price
                holding = 1
                action = 'open_long'
                holding_days = 1
                position = position_new
            # 开空仓
            elif decision_signal <= mean_signal - open_short * std_signal: # <<< 修改点: 使用昨天的决策信号
                pos_ratio = np.tanh(scale * signal_z)
                position_new = (cash / price) * pos_ratio
                fee = abs(position_new * price) * cost_bps / 10000
                cash -= position_new * price + fee # 做空是现金增加，但这里统一处理为减法，因为position_new为负
                entry_price = price
                holding = -1
                action = 'open_short'
                holding_days = 1
                position = position_new
        
        # --- T日收盘后：结算当日净值 ---
        nav = cash + position * price # <<< 修改点: nav用当天的价格计算

        # --- 记录T日的结果 ---
        records.append({
            'date': gold_df.loc[i, 'date'], # <<< 修改点: 记录T日
            'price': price,
            'signal': decision_signal, # 记录下达指令的信号
            'mean_signal': mean_signal,
            'std_signal': std_signal,
            'signal_z': signal_z,
            'position': position, # 记录T日收盘后的仓位
            'cash': cash,
            'nav': nav,
            'action': action
        })
        
    # ... 函数的其余部分（画图和统计）基本不需要修改 ...
    # (此处省略剩余的画图和统计代码，它们可以保持原样)
    # ...
    # bt_df = pd.DataFrame(records).set_index('date')
    # ... [The rest of the function remains the same] ...
    
    # 为了让代码完整，我将剩余部分也复制过来
    if len(records) == 0:
        return None, None
    bt_df = pd.DataFrame(records).set_index('date')
    buy_date_idx = 1
    buy_price = bt_df['price'].iloc[buy_date_idx]
    buy_fee = initial_capital * cost_bps / 10000
    buy_amount = (initial_capital - buy_fee) / buy_price
    bh_nav = pd.Series(index=bt_df.index, dtype=float)
    bh_nav.iloc[0] = initial_capital
    bh_nav.iloc[buy_date_idx:] = buy_amount * bt_df['price'].iloc[buy_date_idx:]
    bt_df['buy_and_hold_nav'] = bh_nav
    bt_df['return'] = bt_df['nav'].pct_change().fillna(0)
    # ... [The rest of the original plotting and summary code]
    # The plotting and summary section of your code should work correctly with the new `bt_df`.
    
    return pd.DataFrame(summary), bt_df # 假设summary是最后生成的
```

### 总结关键修改点：

1.  **循环开始位置**：`for i in range(max(window, window_vola) + 1, ...)`，确保我们总能安全地访问 `i-1` 的数据。
2.  **信号获取**：所有用于决策的信号，如 `decision_signal` 和 `signal_z`，都是基于 `i-1` 日的数据计算的。
3.  **价格获取**：所有用于交易执行的价格 `price`，都是 `i` 日的。
4.  **净值计算**：每日收盘后的账户净值 `nav` 使用的是 `i` 日的收盘价和 `i` 日的最终仓位计算。
5.  **日志记录**：`records.append` 记录的是 `i` 日当天发生的所有事情。

通过以上修改，您的回测框架就消除了前视偏差，更准确地模拟了“昨天决策，今天交易”的真实场景。
