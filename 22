# 这个方法应该放在您的 EnhancedTimingStrategy 类定义内部
    def get_data_after_uptrend_ends(self, num_days_to_get: int = 10) -> list:
        """
        识别上升趋势（绿色部分）结束点，并获取其后连续 N 天的指定数据。

        Args:
            num_days_to_get (int): 上升趋势结束后要获取数据的连续天数。默认为 10。

        Returns:
            list: 一个包含字典的列表，每个字典代表一个上升趋势结束事件，
                  并包含其后 N 天的每日数据。
        """
        if not hasattr(self, 'signals') or \
           not hasattr(self, 'df') or \
           not hasattr(self, 'results'):
            print("错误: 请确保 calc_indicators(), generate_signals(), 和 backtest() 都已运行完毕。")
            return []

        required_signal_cols = ['trend_flag', 'raw_sig', 'signal']
        if not all(col in self.signals.columns for col in required_signal_cols):
            print(f"错误: self.signals 必须包含以下列: {required_signal_cols}")
            return []
        if 'RSI_pct' not in self.df.columns:
            print("错误: self.df 必须包含 'RSI_pct' 列。")
            return []
        
        required_results_cols = ['pos', 'cooldown_active', 'locked_active']
        if not all(col in self.results.columns for col in required_results_cols):
            print(f"错误: self.results 必须包含以下列: {required_results_cols} (需修改 backtest 日志)。")
            return []

        if not isinstance(self.signals.index, pd.DatetimeIndex) or \
           not isinstance(self.df.index, pd.DatetimeIndex) or \
           not isinstance(self.results.index, pd.DatetimeIndex):
            print("错误: 'self.signals', 'self.df', 和 'self.results' 的索引必须是 pandas DatetimeIndex。")
            return []

        print(f"\n--- 分析：上升趋势结束后连续 {num_days_to_get} 天的数据 ---")
        
        last_days_of_uptrends = []
        trend_flag_series = self.signals['trend_flag']

        # 识别上升趋势的最后一天
        for i in range(1, len(trend_flag_series)):
            if trend_flag_series.iloc[i-1] == 1 and trend_flag_series.iloc[i] != 1:
                last_days_of_uptrends.append(trend_flag_series.index[i-1])
        
        if not last_days_of_uptrends:
            print("未找到已结束的上升趋势周期。")
            return []

        all_events_data = []

        for uptrend_end_date in last_days_of_uptrends:
            print(f"\n>> 上升趋势结束于: {uptrend_end_date.strftime('%Y-%m-%d')}")
            
            try:
                if uptrend_end_date in self.results.index:
                    start_index_pos_in_results = self.results.index.get_loc(uptrend_end_date) + 1
                else:
                    potential_start_dates = self.results.index[self.results.index > uptrend_end_date]
                    if potential_start_dates.empty:
                        print(f"  警告: 在 {uptrend_end_date.strftime('%Y-%m-%d')} 之后未找到更多交易日数据。")
                        continue
                    start_index_pos_in_results = self.results.index.get_loc(potential_start_dates[0])
            except KeyError:
                print(f"  警告: 日期 {uptrend_end_date.strftime('%Y-%m-%d')} 在 self.results.index 中未找到或处理时出错。跳过此结束点。")
                continue

            daily_data_for_event = []
            print(f"  获取之后 {num_days_to_get} 天的数据:")
            for day_offset in range(num_days_to_get):
                current_day_index_pos = start_index_pos_in_results + day_offset
                if current_day_index_pos < len(self.results.index):
                    current_analysis_date = self.results.index[current_day_index_pos]
                    
                    data_for_this_day = {'date': current_analysis_date.strftime('%Y-%m-%d')}
                    
                    # 从 self.df 获取 RSI_pct
                    try:
                        data_for_this_day['RSI_pct'] = self.df.loc[current_analysis_date, 'RSI_pct']
                    except KeyError:
                        data_for_this_day['RSI_pct'] = np.nan

                    # 从 self.signals 获取 raw_sig, signal, is_ranging
                    try:
                        data_for_this_day['raw_sig'] = self.signals.loc[current_analysis_date, 'raw_sig']
                        data_for_this_day['signal'] = self.signals.loc[current_analysis_date, 'signal']
                        data_for_this_day['is_ranging'] = (self.signals.loc[current_analysis_date, 'trend_flag'] == 0)
                    except KeyError:
                        data_for_this_day['raw_sig'] = np.nan
                        data_for_this_day['signal'] = np.nan
                        data_for_this_day['is_ranging'] = np.nan

                    # 从 self.results 获取 cooldown_active, locked_active, pos
                    # 之前的检查已保证列存在，这里直接访问
                    data_for_this_day['cooldown_active'] = self.results.loc[current_analysis_date, 'cooldown_active']
                    data_for_this_day['locked_active'] = self.results.loc[current_analysis_date, 'locked_active']
                    data_for_this_day['pos'] = self.results.loc[current_analysis_date, 'pos']
                    
                    daily_data_for_event.append(data_for_this_day)

                    # --- 开始修正 print 语句 ---
                    rsi_pct_val = data_for_this_day.get('RSI_pct')
                    rsi_pct_str = f"{rsi_pct_val:.2f}" if pd.notna(rsi_pct_val) else 'N/A'
                    
                    raw_sig_val = data_for_this_day.get('raw_sig')
                    raw_sig_str = str(raw_sig_val) if pd.notna(raw_sig_val) else 'N/A' # 直接转str，适用于数字
                    
                    signal_val = data_for_this_day.get('signal')
                    signal_str = str(signal_val) if pd.notna(signal_val) else 'N/A' # 直接转str，适用于数字
                    
                    is_ranging_val = data_for_this_day.get('is_ranging') # 这个值可能是 True, False, 或者 np.nan
                    if pd.notna(is_ranging_val):
                        ranging_str = '是' if is_ranging_val == True else '否'
                    else:
                        ranging_str = 'N/A'
                        
                    cooldown_active_val = data_for_this_day.get('cooldown_active') # 这个值是 True 或 False
                    if pd.notna(cooldown_active_val): # 确保它不是从KeyError来的np.nan
                        cooldown_str = '是' if cooldown_active_val == True else '否'
                    else: # 如果因为某种原因变成np.nan
                        cooldown_str = 'N/A'

                    locked_active_val = data_for_this_day.get('locked_active') # 这个值是 True 或 False
                    if pd.notna(locked_active_val): # 确保它不是从KeyError来的np.nan
                        locked_str = '是' if locked_active_val == True else '否'
                    else: # 如果因为某种原因变成np.nan
                        locked_str = 'N/A'
                    
                    pos_val = data_for_this_day.get('pos')
                    pos_str = str(pos_val) if pd.notna(pos_val) else 'N/A' # 直接转str，适用于数字

                    print(f"    {data_for_this_day['date']}: "
                          f"RSI_pct={rsi_pct_str}, "
                          f"raw_sig={raw_sig_str}, "
                          f"signal={signal_str}, "
                          f"ranging={ranging_str}, "
                          f"cooldown={cooldown_str}, "
                          f"locked={locked_str}, "
                          f"pos={pos_str}")
                    # --- 结束修正 print 语句 ---
                else:
                    print(f"    在为 {uptrend_end_date.strftime('%Y-%m-%d')} 获取后续数据时，数据不足 {num_days_to_get} 天。仅获取到 {day_offset} 天。")
                    break
            
            all_events_data.append({
                'uptrend_end_date': uptrend_end_date.strftime('%Y-%m-%d'),
                'consecutive_days_data': daily_data_for_event
            })
        return all_events_data
